from typing import Any, Iterable, Iterator, Set, overload

import numpy as np
import numpy.typing as npt
import open3d.utility
from typing_extensions import Annotated

class CauchyLoss(RobustKernel):
    k: float
    @overload
    def __init__(self, arg0: CauchyLoss) -> None: ...
    @overload
    def __init__(self, k: float) -> None: ...
    def __copy__(self) -> CauchyLoss: ...
    def __deepcopy__(self, arg0: dict) -> CauchyLoss: ...

class CorrespondenceChecker:
    require_pointcloud_alignment_: bool
    def __init__(self, *args, **kwargs) -> None: ...
    def Check(self, source, target, corres, transformation) -> Any: ...

class CorrespondenceCheckerBasedOnDistance(CorrespondenceChecker):
    distance_threshold: float
    @overload
    def __init__(self, arg0: CorrespondenceCheckerBasedOnDistance) -> None: ...
    @overload
    def __init__(self, distance_threshold: float) -> None: ...
    def __copy__(self) -> CorrespondenceCheckerBasedOnDistance: ...
    def __deepcopy__(self, arg0: dict) -> CorrespondenceCheckerBasedOnDistance: ...

class CorrespondenceCheckerBasedOnEdgeLength(CorrespondenceChecker):
    similarity_threshold: float
    @overload
    def __init__(self, arg0: CorrespondenceCheckerBasedOnEdgeLength) -> None: ...
    @overload
    def __init__(self, similarity_threshold: float = ...) -> None: ...
    def __copy__(self) -> CorrespondenceCheckerBasedOnEdgeLength: ...
    def __deepcopy__(self, arg0: dict) -> CorrespondenceCheckerBasedOnEdgeLength: ...

class CorrespondenceCheckerBasedOnNormal(CorrespondenceChecker):
    normal_angle_threshold: float
    @overload
    def __init__(self, arg0: CorrespondenceCheckerBasedOnNormal) -> None: ...
    @overload
    def __init__(self, normal_angle_threshold: float) -> None: ...
    def __copy__(self) -> CorrespondenceCheckerBasedOnNormal: ...
    def __deepcopy__(self, arg0: dict) -> CorrespondenceCheckerBasedOnNormal: ...

class FastGlobalRegistrationOption:
    decrease_mu: bool
    division_factor: float
    iteration_number: int
    maximum_correspondence_distance: float
    maximum_tuple_count: float
    tuple_scale: float
    tuple_test: bool
    use_absolute_scale: bool
    @overload
    def __init__(self, arg0: FastGlobalRegistrationOption) -> None: ...
    @overload
    def __init__(
        self,
        division_factor: float = ...,
        use_absolute_scale: bool = ...,
        decrease_mu: bool = ...,
        maximum_correspondence_distance: float = ...,
        iteration_number: int = ...,
        tuple_scale: float = ...,
        maximum_tuple_count: int = ...,
        tuple_test: bool = ...,
    ) -> None: ...
    def __copy__(self) -> FastGlobalRegistrationOption: ...
    def __deepcopy__(self, arg0: dict) -> FastGlobalRegistrationOption: ...

class Feature:
    data: npt.NDArray[Annotated[np.float64, "m,n"]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Feature) -> None: ...
    def dimension(self) -> Any: ...
    def num(self) -> Any: ...
    def resize(self, dim, n) -> Any: ...
    def __copy__(self) -> Feature: ...
    def __deepcopy__(self, arg0: dict) -> Feature: ...

class GMLoss(RobustKernel):
    k: float
    @overload
    def __init__(self, arg0: GMLoss) -> None: ...
    @overload
    def __init__(self, k: float) -> None: ...
    def __copy__(self) -> GMLoss: ...
    def __deepcopy__(self, arg0: dict) -> GMLoss: ...

class GlobalOptimizationConvergenceCriteria:
    lower_scale_factor: float
    max_iteration: int
    max_iteration_lm: int
    min_relative_increment: float
    min_relative_residual_increment: float
    min_residual: float
    min_right_term: float
    upper_scale_factor: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: GlobalOptimizationConvergenceCriteria) -> None: ...
    def __copy__(self) -> GlobalOptimizationConvergenceCriteria: ...
    def __deepcopy__(self, arg0: dict) -> GlobalOptimizationConvergenceCriteria: ...

class GlobalOptimizationGaussNewton(GlobalOptimizationMethod):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: GlobalOptimizationGaussNewton) -> None: ...
    def __copy__(self) -> GlobalOptimizationGaussNewton: ...
    def __deepcopy__(self, arg0: dict) -> GlobalOptimizationGaussNewton: ...

class GlobalOptimizationLevenbergMarquardt(GlobalOptimizationMethod):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: GlobalOptimizationLevenbergMarquardt) -> None: ...
    def __copy__(self) -> GlobalOptimizationLevenbergMarquardt: ...
    def __deepcopy__(self, arg0: dict) -> GlobalOptimizationLevenbergMarquardt: ...

class GlobalOptimizationMethod:
    def __init__(self, *args, **kwargs) -> None: ...
    def OptimizePoseGraph(self, pose_graph, criteria, option) -> Any: ...

class GlobalOptimizationOption:
    edge_prune_threshold: float
    max_correspondence_distance: float
    preference_loop_closure: float
    reference_node: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: GlobalOptimizationOption) -> None: ...
    @overload
    def __init__(
        self,
        max_correspondence_distance: float = ...,
        edge_prune_threshold: float = ...,
        preference_loop_closure: float = ...,
        reference_node: int = ...,
    ) -> None: ...
    def __copy__(self) -> GlobalOptimizationOption: ...
    def __deepcopy__(self, arg0: dict) -> GlobalOptimizationOption: ...

class HuberLoss(RobustKernel):
    k: float
    @overload
    def __init__(self, arg0: HuberLoss) -> None: ...
    @overload
    def __init__(self, k: float) -> None: ...
    def __copy__(self) -> HuberLoss: ...
    def __deepcopy__(self, arg0: dict) -> HuberLoss: ...

class ICPConvergenceCriteria:
    max_iteration: int
    relative_fitness: float
    relative_rmse: float
    @overload
    def __init__(self, arg0: ICPConvergenceCriteria) -> None: ...
    @overload
    def __init__(
        self,
        relative_fitness: float = ...,
        relative_rmse: float = ...,
        max_iteration: int = ...,
    ) -> None: ...
    def __copy__(self) -> ICPConvergenceCriteria: ...
    def __deepcopy__(self, arg0: dict) -> ICPConvergenceCriteria: ...

class L1Loss(RobustKernel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: L1Loss) -> None: ...
    def __copy__(self) -> L1Loss: ...
    def __deepcopy__(self, arg0: dict) -> L1Loss: ...

class L2Loss(RobustKernel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: L2Loss) -> None: ...
    def __copy__(self) -> L2Loss: ...
    def __deepcopy__(self, arg0: dict) -> L2Loss: ...

class PoseGraph:
    edges: PoseGraphEdgeVector
    nodes: PoseGraphNodeVector
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: PoseGraph) -> None: ...
    def __copy__(self) -> PoseGraph: ...
    def __deepcopy__(self, arg0: dict) -> PoseGraph: ...

class PoseGraphEdge:
    confidence: Annotated[float, "from 0 to 1"]
    information: npt.NDArray[Annotated[np.float64, "6,6"]]
    source_node_id: int
    target_node_id: int
    transformation: npt.NDArray[Annotated[np.float64, "4,4"]]
    uncertain: bool
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: PoseGraphEdge) -> None: ...
    @overload
    def __init__(
        self,
        source_node_id: int = ...,
        target_node_id: int = ...,
        transformation: npt.NDArray[Annotated[np.float64, "4,4"]] = ...,
        information: npt.NDArray[Annotated[np.float64, "6,6"]] = ...,
        uncertain: bool = ...,
        confidence: float = ...,
    ) -> None: ...
    def __copy__(self) -> PoseGraphEdge: ...
    def __deepcopy__(self, arg0: dict) -> PoseGraphEdge: ...

class PoseGraphEdgeVector:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: PoseGraphEdgeVector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: PoseGraphEdge) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: PoseGraphEdgeVector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: PoseGraphEdge) -> None: ...
    @overload
    def pop(self) -> PoseGraphEdge: ...
    @overload
    def pop(self, i: int) -> PoseGraphEdge: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> PoseGraphEdgeVector: ...
    @overload
    def __getitem__(self, arg0: int) -> PoseGraphEdge: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: PoseGraphEdge) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: PoseGraphEdgeVector) -> None: ...

class PoseGraphNode:
    pose: npt.NDArray[Annotated[np.float64, "4,4"]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: PoseGraphNode) -> None: ...
    @overload
    def __init__(self, pose: npt.NDArray[Annotated[np.float64, "4,4"]]) -> None: ...
    def __copy__(self) -> PoseGraphNode: ...
    def __deepcopy__(self, arg0: dict) -> PoseGraphNode: ...

class PoseGraphNodeVector:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: PoseGraphNodeVector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: PoseGraphNode) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: PoseGraphNodeVector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: PoseGraphNode) -> None: ...
    @overload
    def pop(self) -> PoseGraphNode: ...
    @overload
    def pop(self, i: int) -> PoseGraphNode: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> PoseGraphNodeVector: ...
    @overload
    def __getitem__(self, arg0: int) -> PoseGraphNode: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: PoseGraphNode) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: PoseGraphNodeVector) -> None: ...

class RANSACConvergenceCriteria:
    confidence: float
    max_iteration: int
    @overload
    def __init__(self, arg0: RANSACConvergenceCriteria) -> None: ...
    @overload
    def __init__(self, max_iteration: int = ..., confidence: float = ...) -> None: ...
    def __copy__(self) -> RANSACConvergenceCriteria: ...
    def __deepcopy__(self, arg0: dict) -> RANSACConvergenceCriteria: ...

class RegistrationResult:
    correspondence_set: open3d.utility.Vector2iVector
    fitness: float
    inlier_rmse: float
    transformation: npt.NDArray[Annotated[np.float64, "4,4"]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RegistrationResult) -> None: ...
    def __copy__(self) -> RegistrationResult: ...
    def __deepcopy__(self, arg0: dict) -> RegistrationResult: ...

class RobustKernel:
    def __init__(self, *args, **kwargs) -> None: ...
    def weight(self, residual) -> Any: ...

class TransformationEstimation:
    def __init__(self, *args, **kwargs) -> None: ...
    def compute_rmse(self, source, target, corres) -> Any: ...
    def compute_transformation(self, source, target, corres) -> Any: ...

class TransformationEstimationForColoredICP(TransformationEstimation):
    kernel: Any
    lambda_geometric: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TransformationEstimationForColoredICP) -> None: ...
    @overload
    def __init__(self, lambda_geometric: float, kernel) -> None: ...
    @overload
    def __init__(self, lambda_geometric: float) -> None: ...
    @overload
    def __init__(self, kernel) -> None: ...
    def __copy__(self) -> TransformationEstimationForColoredICP: ...
    def __deepcopy__(self, arg0: dict) -> TransformationEstimationForColoredICP: ...

class TransformationEstimationForGeneralizedICP(TransformationEstimation):
    epsilon: float
    kernel: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TransformationEstimationForGeneralizedICP) -> None: ...
    @overload
    def __init__(self, epsilon: float, kernel) -> None: ...
    @overload
    def __init__(self, epsilon: float) -> None: ...
    @overload
    def __init__(self, kernel) -> None: ...
    def __copy__(self) -> TransformationEstimationForGeneralizedICP: ...
    def __deepcopy__(self, arg0: dict) -> TransformationEstimationForGeneralizedICP: ...

class TransformationEstimationPointToPlane(TransformationEstimation):
    kernel: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TransformationEstimationPointToPlane) -> None: ...
    @overload
    def __init__(self, kernel) -> None: ...
    def __copy__(self) -> TransformationEstimationPointToPlane: ...
    def __deepcopy__(self, arg0: dict) -> TransformationEstimationPointToPlane: ...

class TransformationEstimationPointToPoint(TransformationEstimation):
    with_scaling: bool
    @overload
    def __init__(self, arg0: TransformationEstimationPointToPoint) -> None: ...
    @overload
    def __init__(self, with_scaling: bool = ...) -> None: ...
    def __copy__(self) -> TransformationEstimationPointToPoint: ...
    def __deepcopy__(self, arg0: dict) -> TransformationEstimationPointToPoint: ...

class TukeyLoss(RobustKernel):
    k: float
    @overload
    def __init__(self, arg0: TukeyLoss) -> None: ...
    @overload
    def __init__(self, k: float) -> None: ...
    def __copy__(self) -> TukeyLoss: ...
    def __deepcopy__(self, arg0: dict) -> TukeyLoss: ...

def compute_fpfh_feature(input, search_param) -> Any: ...
def evaluate_registration(
    source, target, max_correspondence_distance, transformation=...
) -> Any: ...
def get_information_matrix_from_point_clouds(
    source, target, max_correspondence_distance, transformation
) -> Any: ...
def global_optimization(pose_graph, method, criteria, option) -> Any: ...
def registration_colored_icp(
    source,
    target,
    max_correspondence_distance,
    init=...,
    estimation_method=...,
    criteria=...,
    relative_rmse=...,
    andmax_iteration=...,
) -> Any: ...
def registration_fgr_based_on_correspondence(
    source, target, corres, option=...
) -> Any: ...
def registration_fgr_based_on_feature_matching(
    source, target, source_feature, target_feature, option=...
) -> Any: ...
def registration_generalized_icp(
    source,
    target,
    max_correspondence_distance,
    init=...,
    estimation_method=...,
    criteria=...,
    relative_rmse=...,
    andmax_iteration=...,
) -> Any: ...
def registration_icp(
    source,
    target,
    max_correspondence_distance,
    init=...,
    estimation_method=...,
    criteria=...,
    relative_rmse=...,
    andmax_iteration=...,
) -> Any: ...
def registration_ransac_based_on_correspondence(
    source,
    target,
    corres,
    max_correspondence_distance,
    estimation_method=...,
    ransac_n=...,
    checkers=...,
    criteria=...,
    andconfidence=...,
) -> Any: ...
def registration_ransac_based_on_feature_matching(
    source,
    target,
    source_feature,
    target_feature,
    mutual_filter,
    max_correspondence_distance,
    estimation_method=...,
    ransac_n=...,
    checkers=...,
    criteria=...,
    andconfidence=...,
) -> Any: ...

__all__ = [
    "CauchyLoss",
    "CorrespondenceChecker",
    "CorrespondenceCheckerBasedOnDistance",
    "CorrespondenceCheckerBasedOnEdgeLength",
    "CorrespondenceCheckerBasedOnNormal",
    "FastGlobalRegistrationOption",
    "Feature",
    "GMLoss",
    "GlobalOptimizationConvergenceCriteria",
    "GlobalOptimizationGaussNewton",
    "GlobalOptimizationLevenbergMarquardt",
    "GlobalOptimizationMethod",
    "GlobalOptimizationOption",
    "HuberLoss",
    "ICPConvergenceCriteria",
    "L1Loss",
    "L2Loss",
    "PoseGraph",
    "PoseGraphEdge",
    "PoseGraphEdgeVector",
    "PoseGraphNode",
    "PoseGraphNodeVector",
    "RANSACConvergenceCriteria",
    "RegistrationResult",
    "RobustKernel",
    "TransformationEstimation",
    "TransformationEstimationForColoredICP",
    "TransformationEstimationForGeneralizedICP",
    "TransformationEstimationPointToPlane",
    "TransformationEstimationPointToPoint",
    "TukeyLoss",
    "compute_fpfh_feature",
    "evaluate_registration",
    "get_information_matrix_from_point_clouds",
    "global_optimization",
    "registration_colored_icp",
    "registration_fgr_based_on_correspondence",
    "registration_fgr_based_on_feature_matching",
    "registration_generalized_icp",
    "registration_icp",
    "registration_ransac_based_on_correspondence",
    "registration_ransac_based_on_feature_matching",
]
