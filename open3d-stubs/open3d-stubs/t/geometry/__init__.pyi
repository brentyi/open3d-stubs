from typing import Any, ClassVar, Dict, Iterator, List, Optional, Set, Tuple, overload

import numpy as np
import numpy.typing as npt
import open3d.core
import open3d.geometry
from typing_extensions import Annotated

Cubic: InterpType
Lanczos: InterpType
Linear: InterpType
Nearest: InterpType
Super: InterpType

class AxisAlignedBoundingBox(Geometry, DrawableGeometry):
    @overload
    def __init__(self, device=...) -> None: ...
    @overload
    def __init__(self, min_bound, max_bound) -> None: ...
    def clone(self) -> AxisAlignedBoundingBox: ...
    def cpu(self) -> AxisAlignedBoundingBox: ...
    def create_from_points(self, *args, **kwargs) -> Any: ...
    def cuda(self, device_id: int = ...) -> AxisAlignedBoundingBox: ...
    def from_legacy(self, *args, **kwargs) -> Any: ...
    def get_box_points(self) -> open3d.core.Tensor: ...
    def get_center(self) -> open3d.core.Tensor: ...
    def get_color(self) -> open3d.core.Tensor: ...
    def get_extent(self) -> open3d.core.Tensor: ...
    def get_half_extent(self) -> open3d.core.Tensor: ...
    def get_max_bound(self) -> open3d.core.Tensor: ...
    def get_max_extent(self) -> float: ...
    def get_min_bound(self) -> open3d.core.Tensor: ...
    def get_point_indices_within_bounding_box(self, points) -> Any: ...
    @overload
    def scale(self, scale, center) -> Any: ...
    @overload
    def scale(float) -> Any: ...
    def set_color(self, color) -> Any: ...
    def set_max_bound(self, max_bound) -> Any: ...
    def set_min_bound(self, min_bound) -> Any: ...
    def to(
        self, device: open3d.core.Device, copy: bool = ...
    ) -> AxisAlignedBoundingBox: ...
    def to_legacy(self) -> open3d.geometry.AxisAlignedBoundingBox: ...
    def translate(self, translation, relative=...) -> Any: ...
    def volume(self) -> float: ...
    def __add__(self, arg0: AxisAlignedBoundingBox) -> AxisAlignedBoundingBox: ...

class DrawableGeometry:
    material: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def has_valid_material(self) -> bool: ...

class Geometry:
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self) -> Any: ...
    def is_empty(self) -> Any: ...
    @property
    def device(self) -> open3d.core.Device: ...
    @property
    def is_cpu(self) -> bool: ...
    @property
    def is_cuda(self) -> bool: ...

class Image(Geometry):
    @overload
    def __init__(
        self, rows=..., cols=..., channels=..., dtype=..., device=...
    ) -> None: ...
    @overload
    def __init__(self, tensor) -> None: ...
    def as_tensor(self) -> open3d.core.Tensor: ...
    def clear(self) -> Any: ...
    def clip_transform(
        self, scale: float, min_value: float, max_value: float, clip_fill: float = ...
    ) -> Image: ...
    def clone(self) -> Image: ...
    def colorize_depth(
        self, scale: float, min_value: float, max_value: float
    ) -> Image: ...
    def cpu(self) -> Image: ...
    def create_normal_map(self, invalid_fill: float = ...) -> Image: ...
    def create_vertex_map(
        self, intrinsics: open3d.core.Tensor, invalid_fill: float = ...
    ) -> Image: ...
    def cuda(self, device_id: int = ...) -> Image: ...
    def dilate(self, kernel_size: int = ...) -> Image: ...
    def filter(self, kernel: open3d.core.Tensor) -> Image: ...
    def filter_bilateral(
        self, kernel_size: int = ..., value_sigma: float = ..., dist_sigma: float = ...
    ) -> Image: ...
    def filter_gaussian(self, kernel_size: int = ..., sigma: float = ...) -> Image: ...
    def filter_sobel(self, kernel_size: int = ...) -> Tuple[Image, Image]: ...
    def from_legacy(self, *args, **kwargs) -> Any: ...
    def get_max_bound(self) -> Any: ...
    def get_min_bound(self) -> Any: ...
    def is_empty(self) -> Any: ...
    def linear_transform(self, scale=..., offset=...) -> Any: ...
    def pyrdown(self) -> Image: ...
    def resize(
        self, sampling_rate: float = ..., interp_type: InterpType = ...
    ) -> Image: ...
    def rgb_to_gray(self) -> Image: ...
    @overload
    def to(self, device, copy=...) -> Any: ...
    @overload
    def to(self, dtype, scale=..., offset=..., copy=...) -> Any: ...
    def to_legacy(self) -> Any: ...
    @property
    def channels(self) -> int: ...
    @property
    def columns(self) -> int: ...
    @property
    def device(self) -> open3d.core.Device: ...
    @property
    def dtype(self) -> open3d.core.Dtype: ...
    @property
    def rows(self) -> int: ...

class InterpType:
    __members__: ClassVar[dict] = ...  # read-only
    Cubic: ClassVar[InterpType] = ...
    Lanczos: ClassVar[InterpType] = ...
    Linear: ClassVar[InterpType] = ...
    Nearest: ClassVar[InterpType] = ...
    Super: ClassVar[InterpType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LineSet(Geometry, DrawableGeometry):
    @overload
    def __init__(self, device=...) -> None: ...
    @overload
    def __init__(self, point_positions, line_indices) -> None: ...
    def clone(self) -> LineSet: ...
    def cpu(self) -> LineSet: ...
    def cuda(self, device_id: int = ...) -> LineSet: ...
    def from_legacy(self, *args, **kwargs) -> Any: ...
    def get_axis_aligned_bounding_box(self, *args, **kwargs) -> Any: ...
    def get_center(self) -> open3d.core.Tensor: ...
    def get_max_bound(self) -> open3d.core.Tensor: ...
    def get_min_bound(self) -> open3d.core.Tensor: ...
    def rotate(self, R, center) -> Any: ...
    @overload
    def scale(self, scale, center) -> Any: ...
    @overload
    def scale(float) -> Any: ...
    def to(self, device: open3d.core.Device, copy: bool = ...) -> LineSet: ...
    def to_legacy(self) -> open3d.geometry.LineSet: ...
    def transform(self, transformation) -> Any: ...
    def translate(self, translation, relative=...) -> Any: ...
    @property
    def line(self) -> TensorMap: ...
    @property
    def point(self) -> TensorMap: ...

class PointCloud(Geometry, DrawableGeometry):
    @overload
    def __init__(self, device: open3d.core.Device = ...) -> None: ...
    @overload
    def __init__(self, positions: open3d.core.Tensor) -> None: ...
    @overload
    def __init__(self, map_keys_to_tensors: Dict[str, open3d.core.Tensor]) -> None: ...
    def append(self, arg0: PointCloud) -> PointCloud: ...
    def clone(self) -> PointCloud: ...
    def cluster_dbscan(self, eps, min_points, print_progress=...) -> Any: ...
    def compute_convex_hull(self) -> Any: ...
    def cpu(self) -> PointCloud: ...
    def create_from_depth_image(self, *args, **kwargs) -> Any: ...
    def create_from_rgbd_image(self, *args, **kwargs) -> Any: ...
    def crop(self, aabb, invert=...) -> Any: ...
    def cuda(self, device_id: int = ...) -> PointCloud: ...
    def estimate_color_gradients(
        self, max_nn: int = ..., radius: Optional[float] = ...
    ) -> None: ...
    def estimate_normals(self, max_nn=..., radius=...) -> Any: ...
    def from_legacy(self, *args, **kwargs) -> Any: ...
    def get_axis_aligned_bounding_box(self, *args, **kwargs) -> Any: ...
    def get_center(self) -> open3d.core.Tensor: ...
    def get_max_bound(self) -> open3d.core.Tensor: ...
    def get_min_bound(self) -> open3d.core.Tensor: ...
    def paint_uniform_color(self, color) -> Any: ...
    def project_to_depth_image(self, *args, **kwargs) -> Any: ...
    def project_to_rgbd_image(self, *args, **kwargs) -> Any: ...
    def random_down_sample(self, sampling_ratio) -> Any: ...
    def remove_non_finite_points(
        self, remove_nan: bool = ..., remove_infinite: bool = ...
    ) -> Tuple[PointCloud, open3d.core.Tensor]: ...
    def remove_radius_outliers(self, nb_points, search_radius) -> Any: ...
    def rotate(
        self, R: open3d.core.Tensor, center: open3d.core.Tensor
    ) -> PointCloud: ...
    def scale(self, scale: float, center: open3d.core.Tensor) -> PointCloud: ...
    def select_by_index(self, indices, invert=..., remove_duplicates=...) -> Any: ...
    def select_by_mask(self, boolean_mask, invert=...) -> Any: ...
    def to(self, device: open3d.core.Device, copy: bool = ...) -> PointCloud: ...
    def to_legacy(self) -> open3d.geometry.PointCloud: ...
    def transform(self, transformation: open3d.core.Tensor) -> PointCloud: ...
    def translate(
        self, translation: open3d.core.Tensor, relative: bool = ...
    ) -> PointCloud: ...
    def uniform_down_sample(self, every_k_points) -> Any: ...
    def voxel_down_sample(self, voxel_size) -> Any: ...
    def __add__(self, arg0: PointCloud) -> PointCloud: ...
    @property
    def point(self) -> TensorMap: ...

class RGBDImage(Geometry):
    aligned_: bool
    color: Image
    depth: Image
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, color, depth, aligned=...) -> None: ...
    def are_aligned(self) -> bool: ...
    def clear(self) -> Any: ...
    def clone(self) -> RGBDImage: ...
    def cpu(self) -> RGBDImage: ...
    def cuda(self, device_id: int = ...) -> RGBDImage: ...
    def get_max_bound(self) -> Any: ...
    def get_min_bound(self) -> Any: ...
    def is_empty(self) -> Any: ...
    def to(self, device: open3d.core.Device, copy: bool = ...) -> RGBDImage: ...
    def to_legacy(self) -> Any: ...

class RaycastingScene:
    INVALID_ID: ClassVar[int] = ...  # read-only
    def __init__(self, nthreads: int = ...) -> None: ...
    @overload
    def add_triangles(
        self, vertex_positions: open3d.core.Tensor, triangle_indices: open3d.core.Tensor
    ) -> int: ...
    @overload
    def add_triangles(self, mesh: TriangleMesh) -> int: ...
    def cast_rays(
        self, rays: open3d.core.Tensor, nthreads: int = ...
    ) -> Dict[str, open3d.core.Tensor]: ...
    def compute_closest_points(
        self, query_points: open3d.core.Tensor, nthreads: int = ...
    ) -> Dict[str, open3d.core.Tensor]: ...
    def compute_distance(
        self, query_points: open3d.core.Tensor, nthreads: int = ...
    ) -> open3d.core.Tensor: ...
    def compute_occupancy(
        self, query_points: open3d.core.Tensor, nthreads: int = ...
    ) -> open3d.core.Tensor: ...
    def compute_signed_distance(
        self, query_points: open3d.core.Tensor, nthreads: int = ...
    ) -> open3d.core.Tensor: ...
    def count_intersections(
        self, rays: open3d.core.Tensor, nthreads: int = ...
    ) -> open3d.core.Tensor: ...
    def create_rays_pinhole(self, *args, **kwargs) -> Any: ...
    def test_occlusions(
        self,
        rays: open3d.core.Tensor,
        tnear: float = ...,
        tfar: float = ...,
        nthreads: int = ...,
    ) -> open3d.core.Tensor: ...

class TensorMap:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, primary_key: str) -> None: ...
    @overload
    def __init__(
        self, primary_key: str, map_keys_to_tensors: Dict[str, open3d.core.Tensor]
    ) -> None: ...
    def assert_size_synchronized(self) -> None: ...
    def erase(self, arg0: str) -> int: ...
    def get_primary_key(self) -> str: ...
    def is_size_synchronized(self) -> bool: ...
    def items(self) -> Iterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg0: str) -> bool: ...
    def __delitem__(self, arg0: str) -> int: ...
    def __getitem__(self, arg0: str) -> open3d.core.Tensor: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: open3d.core.Tensor) -> None: ...

class TriangleMesh(Geometry, DrawableGeometry):
    @overload
    def __init__(self, device: open3d.core.Device = ...) -> None: ...
    @overload
    def __init__(
        self, vertex_positions: open3d.core.Tensor, triangle_indices: open3d.core.Tensor
    ) -> None: ...
    @overload
    def boolean_difference(
        self, mesh: TriangleMesh, tolerance: float = ...
    ) -> TriangleMesh: ...
    @overload
    def boolean_difference(sphere) -> Any: ...
    @overload
    def boolean_intersection(
        self, mesh: TriangleMesh, tolerance: float = ...
    ) -> TriangleMesh: ...
    @overload
    def boolean_intersection(sphere) -> Any: ...
    @overload
    def boolean_union(
        self, mesh: TriangleMesh, tolerance: float = ...
    ) -> TriangleMesh: ...
    @overload
    def boolean_union(sphere) -> Any: ...
    @overload
    def clip_plane(
        self, point: open3d.core.Tensor, normal: open3d.core.Tensor
    ) -> TriangleMesh: ...
    @overload
    def clip_plane(point=..., normal=...) -> Any: ...
    def clone(self) -> TriangleMesh: ...
    @overload
    def compute_convex_hull(self, joggle_inputs: bool = ...) -> TriangleMesh: ...
    def cpu(self) -> TriangleMesh: ...
    def create_arrow(self, *args, **kwargs) -> Any: ...
    def create_box(self, *args, **kwargs) -> Any: ...
    def create_cone(self, *args, **kwargs) -> Any: ...
    def create_coordinate_frame(self, *args, **kwargs) -> Any: ...
    def create_cylinder(self, *args, **kwargs) -> Any: ...
    def create_icosahedron(self, *args, **kwargs) -> Any: ...
    def create_mobius(self, *args, **kwargs) -> Any: ...
    def create_octahedron(self, *args, **kwargs) -> Any: ...
    def create_sphere(self, *args, **kwargs) -> Any: ...
    def create_tetrahedron(self, *args, **kwargs) -> Any: ...
    def create_text(self, *args, **kwargs) -> Any: ...
    def create_torus(self, *args, **kwargs) -> Any: ...
    def cuda(self, device_id: int = ...) -> TriangleMesh: ...
    @overload
    def fill_holes(self, hole_size: float = ...) -> TriangleMesh: ...
    def from_legacy(self, *args, **kwargs) -> Any: ...
    def get_axis_aligned_bounding_box(self, *args, **kwargs) -> Any: ...
    def get_center(self) -> open3d.core.Tensor: ...
    def get_max_bound(self) -> open3d.core.Tensor: ...
    def get_min_bound(self) -> open3d.core.Tensor: ...
    def rotate(
        self, R: open3d.core.Tensor, center: open3d.core.Tensor
    ) -> TriangleMesh: ...
    def scale(self, scale: float, center: open3d.core.Tensor) -> TriangleMesh: ...
    def simplify_quadric_decimation(
        self, target_reduction: float, preserve_volume: bool = ...
    ) -> TriangleMesh: ...
    def slice_plane(
        self,
        point: open3d.core.Tensor,
        normal: open3d.core.Tensor,
        contour_values: List[float] = ...,
    ) -> LineSet: ...
    def to(self, device: open3d.core.Device, copy: bool = ...) -> TriangleMesh: ...
    def to_legacy(self) -> open3d.geometry.TriangleMesh: ...
    def transform(self, transformation: open3d.core.Tensor) -> TriangleMesh: ...
    def translate(
        self, translation: open3d.core.Tensor, relative: bool = ...
    ) -> TriangleMesh: ...
    @property
    def triangle(self) -> TensorMap: ...
    @property
    def vertex(self) -> TensorMap: ...

class VoxelBlockGrid:
    def __init__(
        self,
        attr_names: List[str],
        attr_dtypes: List[open3d.core.Dtype],
        attr_channels: List[open3d.core.SizeVector],
        voxel_size: float = ...,
        block_resolution: int = ...,
        block_count: int = ...,
        device: open3d.core.Device = ...,
    ) -> None: ...
    def attribute(self, attribute_name: str) -> open3d.core.Tensor: ...
    @overload
    def compute_unique_block_coordinates(
        self,
        depth: Image,
        intrinsic: open3d.core.Tensor,
        extrinsic: open3d.core.Tensor,
        depth_scale: float = ...,
        depth_max: float = ...,
        trunc_voxel_multiplier: float = ...,
    ) -> open3d.core.Tensor: ...
    @overload
    def compute_unique_block_coordinates(
        self, pcd: PointCloud, trunc_voxel_multiplier: float = ...
    ) -> open3d.core.Tensor: ...
    def extract_point_cloud(
        self, weight_threshold: float = ..., estimated_point_number: int = ...
    ) -> PointCloud: ...
    def extract_triangle_mesh(
        self, weight_threshold: float = ..., estimated_vertex_number: int = ...
    ) -> TriangleMesh: ...
    def hashmap(self) -> open3d.core.HashMap: ...
    @overload
    def integrate(
        self,
        block_coords: open3d.core.Tensor,
        depth: Image,
        color: Image,
        depth_intrinsic: open3d.core.Tensor,
        color_intrinsic: open3d.core.Tensor,
        extrinsic: open3d.core.Tensor,
        depth_scale: float = ...,
        depth_max: float = ...,
        trunc_voxel_multiplier: float = ...,
    ) -> None: ...
    @overload
    def integrate(
        self,
        block_coords: open3d.core.Tensor,
        depth: Image,
        color: Image,
        intrinsic: open3d.core.Tensor,
        extrinsic: open3d.core.Tensor,
        depth_scale: float = ...,
        depth_max: float = ...,
        trunc_voxel_multiplier: float = ...,
    ) -> None: ...
    @overload
    def integrate(
        self,
        block_coords: open3d.core.Tensor,
        depth: Image,
        intrinsic: open3d.core.Tensor,
        extrinsic: open3d.core.Tensor,
        depth_scale: float = ...,
        depth_max: float = ...,
        trunc_voxel_multiplier: float = ...,
    ) -> None: ...
    def load(self, *args, **kwargs) -> Any: ...
    def ray_cast(
        self,
        block_coords: open3d.core.Tensor,
        intrinsic: open3d.core.Tensor,
        extrinsic: open3d.core.Tensor,
        width: int,
        height: int,
        render_attributes: List[str] = ...,
        depth_scale: float = ...,
        depth_min: float = ...,
        depth_max: float = ...,
        weight_threshold: float = ...,
        trunc_voxel_multiplier: float = ...,
        range_map_down_factor: int = ...,
    ) -> TensorMap: ...
    def save(self, file_name: str) -> None: ...
    def voxel_coordinates(
        self, voxel_indices: open3d.core.Tensor
    ) -> open3d.core.Tensor: ...
    @overload
    def voxel_coordinates_and_flattened_indices(
        self, buf_indices: open3d.core.Tensor
    ) -> Tuple[open3d.core.Tensor, open3d.core.Tensor]: ...
    @overload
    def voxel_coordinates_and_flattened_indices(
        self,
    ) -> Tuple[open3d.core.Tensor, open3d.core.Tensor]: ...
    @overload
    def voxel_indices(self, arg0: open3d.core.Tensor) -> open3d.core.Tensor: ...
    @overload
    def voxel_indices(self) -> open3d.core.Tensor: ...

__all__ = [
    "Cubic",
    "Lanczos",
    "Linear",
    "Nearest",
    "Super",
    "AxisAlignedBoundingBox",
    "DrawableGeometry",
    "Geometry",
    "Image",
    "InterpType",
    "LineSet",
    "PointCloud",
    "RGBDImage",
    "RaycastingScene",
    "TensorMap",
    "TriangleMesh",
    "VoxelBlockGrid",
]
