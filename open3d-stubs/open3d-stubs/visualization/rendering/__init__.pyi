from typing import Any, Callable, ClassVar, Dict, List, Set, overload

import numpy as np
import numpy.typing as npt
import open3d.camera
import open3d.geometry
import open3d.t.geometry
from typing_extensions import Annotated

class Camera:
    class FovType:
        __members__: ClassVar[dict] = ...  # read-only
        Horizontal: ClassVar[Camera.FovType] = ...
        Vertical: ClassVar[Camera.FovType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Projection:
        __members__: ClassVar[dict] = ...  # read-only
        Ortho: ClassVar[Camera.Projection] = ...
        Perspective: ClassVar[Camera.Projection] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Horizontal: ClassVar[Camera.FovType] = ...
    Ortho: ClassVar[Camera.Projection] = ...
    Perspective: ClassVar[Camera.Projection] = ...
    Vertical: ClassVar[Camera.FovType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def copy_from(self, arg0: Camera) -> None: ...
    def get_far(self) -> float: ...
    def get_field_of_view(self) -> float: ...
    def get_field_of_view_type(self) -> Camera.FovType: ...
    def get_model_matrix(self) -> npt.NDArray[Annotated[np.int32, "4,4"]]: ...
    def get_near(self) -> float: ...
    def get_projection_matrix(self) -> npt.NDArray[Annotated[np.int32, "4,4"]]: ...
    def get_view_matrix(self) -> npt.NDArray[Annotated[np.int32, "4,4"]]: ...
    @overload
    def look_at(
        self,
        arg0: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: npt.NDArray[Annotated[np.int32, "3,1"]],
    ) -> None: ...
    @overload
    def look_at(center, eye, up) -> Any: ...
    @overload
    def set_projection(
        self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: Camera.FovType
    ) -> None: ...
    @overload
    def set_projection(
        field_of_view, aspect_ratio, far_plane, field_of_view_type
    ) -> Any: ...
    @overload
    def set_projection(
        self,
        arg0: Camera.Projection,
        arg1: float,
        arg2: float,
        arg3: float,
        arg4: float,
        arg5: float,
        arg6: float,
    ) -> None: ...
    @overload
    def set_projection(projection_type, left, right, bottom, top, near, far) -> Any: ...
    @overload
    def set_projection(
        self,
        arg0: npt.NDArray[Annotated[np.float64, "3,3"]],
        arg1: float,
        arg2: float,
        arg3: float,
        arg4: float,
    ) -> None: ...
    @overload
    def set_projection(
        intrinsics, near_place, far_plane, image_width, image_height
    ) -> Any: ...
    @overload
    def unproject(
        self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float
    ) -> npt.NDArray[Annotated[np.int32, "3,1"]]: ...
    @overload
    def unproject(x, y, z, view_width, view_height) -> Any: ...

class ColorGrading:
    class Quality:
        __members__: ClassVar[dict] = ...  # read-only
        HIGH: ClassVar[ColorGrading.Quality] = ...
        LOW: ClassVar[ColorGrading.Quality] = ...
        MEDIUM: ClassVar[ColorGrading.Quality] = ...
        ULTRA: ClassVar[ColorGrading.Quality] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ToneMapping:
        __members__: ClassVar[dict] = ...  # read-only
        ACES: ClassVar[ColorGrading.ToneMapping] = ...
        ACES_LEGACY: ClassVar[ColorGrading.ToneMapping] = ...
        DISPLAY_RANGE: ClassVar[ColorGrading.ToneMapping] = ...
        FILMIC: ClassVar[ColorGrading.ToneMapping] = ...
        LINEAR: ClassVar[ColorGrading.ToneMapping] = ...
        REINHARD: ClassVar[ColorGrading.ToneMapping] = ...
        UCHIMURA: ClassVar[ColorGrading.ToneMapping] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    quality: ColorGrading.Quality
    temperature: float
    tint: float
    tone_mapping: ColorGrading.ToneMapping
    def __init__(
        self, arg0: ColorGrading.Quality, arg1: ColorGrading.ToneMapping
    ) -> None: ...

class Gradient:
    class Mode:
        __members__: ClassVar[dict] = ...  # read-only
        GRADIENT: ClassVar[Gradient.Mode] = ...
        LUT: ClassVar[Gradient.Mode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Point:
        color: npt.NDArray[Annotated[np.int32, "4,1"]]
        value: float
        def __init__(
            self, arg0: float, arg1: npt.NDArray[Annotated[np.int32, "4,1"]]
        ) -> None: ...
    GRADIENT: ClassVar[Gradient.Mode] = ...
    LUT: ClassVar[Gradient.Mode] = ...
    mode: Gradient.Mode
    points: List[Gradient.Point]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: List[Gradient.Point]) -> None: ...

class MaterialRecord:
    absorption_color: npt.NDArray[Annotated[np.int32, "3,1"]]
    absorption_distance: float
    albedo_img: open3d.geometry.Image
    anisotropy_img: open3d.geometry.Image
    ao_img: open3d.geometry.Image
    ao_rough_metal_img: open3d.geometry.Image
    aspect_ratio: float
    base_anisotropy: float
    base_clearcoat: float
    base_clearcoat_roughness: float
    base_color: npt.NDArray[Annotated[np.int32, "4,1"]]
    base_metallic: float
    base_reflectance: float
    base_roughness: float
    clearcoat_img: open3d.geometry.Image
    clearcoat_roughness_img: open3d.geometry.Image
    generic_imgs: Dict[str, open3d.geometry.Image]
    generic_params: Dict[str, npt.NDArray[Annotated[np.int32, "4,1"]]]
    gradient: Gradient
    ground_plane_axis: float
    has_alpha: bool
    line_width: float
    metallic_img: open3d.geometry.Image
    normal_img: open3d.geometry.Image
    point_size: float
    reflectance_img: open3d.geometry.Image
    roughness_img: open3d.geometry.Image
    sRGB_color: bool
    scalar_max: float
    scalar_min: float
    shader: str
    thickness: float
    transmission: float
    def __init__(self) -> None: ...

class OffscreenRenderer:
    def __init__(
        self, width: int, height: int, resource_path: str = ..., headless: bool = ...
    ) -> None: ...
    def render_to_depth_image(
        self, z_in_view_space: bool = ...
    ) -> open3d.geometry.Image: ...
    def render_to_image(self) -> open3d.geometry.Image: ...
    @overload
    def setup_camera(
        self,
        arg0: float,
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg3: npt.NDArray[Annotated[np.int32, "3,1"]],
    ) -> None: ...
    @overload
    def setup_camera(vertical_field_of_view, center, eye, up) -> Any: ...
    @overload
    def setup_camera(
        self,
        arg0: open3d.camera.PinholeCameraIntrinsic,
        arg1: npt.NDArray[Annotated[np.float64, "4,4"]],
    ) -> None: ...
    @overload
    def setup_camera(intrinsics, extrinsic_matrix) -> Any: ...
    @overload
    def setup_camera(
        self,
        arg0: npt.NDArray[Annotated[np.float64, "3,3"]],
        arg1: npt.NDArray[Annotated[np.float64, "4,4"]],
        arg2: int,
        arg3: int,
    ) -> None: ...
    @overload
    def setup_camera(
        intrinsic_matrix, extrinsic_matrix, intrinsic_width_px, intrinsic_height_px
    ) -> Any: ...
    @property
    def scene(self) -> Any: ...

class Open3DScene:
    class LightingProfile:
        __members__: ClassVar[dict] = ...  # read-only
        DARK_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
        HARD_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
        MED_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
        NO_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
        SOFT_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    DARK_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
    HARD_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
    MED_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
    NO_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
    SOFT_SHADOWS: ClassVar[Open3DScene.LightingProfile] = ...
    downsample_threshold: int
    def __init__(self, arg0: Renderer) -> None: ...
    @overload
    def add_geometry(
        self,
        name: str,
        geometry: open3d.geometry.Geometry3D,
        material: MaterialRecord,
        add_downsampled_copy_for_fast_rendering: bool = ...,
    ) -> None: ...
    @overload
    def add_geometry(
        self,
        name: str,
        geometry: open3d.t.geometry.Geometry,
        material: MaterialRecord,
        add_downsampled_copy_for_fast_rendering: bool = ...,
    ) -> None: ...
    def add_model(self, arg0: str, arg1: TriangleMeshModel) -> None: ...
    def clear_geometry(self) -> None: ...
    @overload
    def geometry_is_visible(self, arg0: str) -> bool: ...
    @overload
    def geometry_is_visible(name) -> Any: ...
    @overload
    def get_geometry_transform(
        self, arg0: str
    ) -> npt.NDArray[Annotated[np.float64, "4,4"]]: ...
    @overload
    def get_geometry_transform(name) -> Any: ...
    @overload
    def has_geometry(self, arg0: str) -> bool: ...
    @overload
    def has_geometry(name) -> Any: ...
    @overload
    def modify_geometry_material(self, arg0: str, arg1: MaterialRecord) -> None: ...
    @overload
    def modify_geometry_material(name, material) -> Any: ...
    def remove_geometry(self, arg0: str) -> None: ...
    def set_background(
        self,
        color: npt.NDArray[Annotated[np.int32, "4,1"]],
        image: open3d.geometry.Image = ...,
    ) -> None: ...
    def set_background_color(
        self, arg0: npt.NDArray[Annotated[np.int32, "4,1"]]
    ) -> None: ...
    @overload
    def set_geometry_transform(
        self, arg0: str, arg1: npt.NDArray[Annotated[np.float64, "4,4"]]
    ) -> None: ...
    @overload
    def set_geometry_transform(name, transform) -> Any: ...
    def set_lighting(
        self,
        arg0: Open3DScene.LightingProfile,
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
    ) -> None: ...
    def set_view_size(self, arg0: int, arg1: int) -> None: ...
    def show_axes(self, arg0: bool) -> None: ...
    def show_geometry(self, arg0: str, arg1: bool) -> None: ...
    def show_ground_plane(self, arg0: bool, arg1: Scene.GroundPlane) -> None: ...
    def show_skybox(self, arg0: bool) -> None: ...
    def update_material(self, arg0: MaterialRecord) -> None: ...
    @property
    def background_color(self) -> npt.NDArray[Annotated[np.int32, "4,1"]]: ...
    @property
    def bounding_box(self) -> open3d.geometry.AxisAlignedBoundingBox: ...
    @property
    def camera(self) -> Camera: ...
    @property
    def scene(self) -> Scene: ...
    @property
    def view(self) -> View: ...

class Renderer:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_texture(self, *args, **kwargs) -> Any: ...
    def remove_texture(self, arg0) -> None: ...
    def set_clear_color(
        self, arg0: npt.NDArray[Annotated[np.int32, "4,1"]]
    ) -> None: ...
    @overload
    def update_texture(
        self, texture, image: open3d.geometry.Image, is_sRGB: bool = ...
    ) -> bool: ...

class Scene:
    class GroundPlane:
        __members__: ClassVar[dict] = ...  # read-only
        XY: ClassVar[Scene.GroundPlane] = ...
        XZ: ClassVar[Scene.GroundPlane] = ...
        YZ: ClassVar[Scene.GroundPlane] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    UPDATE_COLORS_FLAG: ClassVar[int] = ...
    UPDATE_NORMALS_FLAG: ClassVar[int] = ...
    UPDATE_POINTS_FLAG: ClassVar[int] = ...
    UPDATE_UV0_FLAG: ClassVar[int] = ...
    XY: ClassVar[Scene.GroundPlane] = ...
    XZ: ClassVar[Scene.GroundPlane] = ...
    YZ: ClassVar[Scene.GroundPlane] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def add_camera(self, arg0: str, arg1: Camera) -> None: ...
    def add_directional_light(
        self,
        arg0: str,
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg3: float,
        arg4: bool,
    ) -> bool: ...
    @overload
    def add_geometry(
        self,
        name: str,
        geometry: open3d.geometry.Geometry3D,
        material: MaterialRecord,
        downsampled_name: str = ...,
        downsample_threshold: int = ...,
    ) -> bool: ...
    @overload
    def add_geometry(
        self,
        name: str,
        geometry: open3d.t.geometry.Geometry,
        material: MaterialRecord,
        downsampled_name: str = ...,
        downsample_threshold: int = ...,
    ) -> bool: ...
    @overload
    def add_point_light(
        self,
        arg0: str,
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg3: float,
        arg4: float,
        arg5: bool,
    ) -> bool: ...
    @overload
    def add_point_light(
        name, color, position, intensity, falloff, cast_shadows
    ) -> Any: ...
    def add_spot_light(
        self,
        arg0: str,
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg3: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg4: float,
        arg5: float,
        arg6: float,
        arg7: float,
        arg8: bool,
    ) -> bool: ...
    def enable_indirect_light(self, arg0: bool) -> None: ...
    @overload
    def enable_light_shadow(self, arg0: str, arg1: bool) -> None: ...
    @overload
    def enable_light_shadow(name, can_cast_shadows) -> Any: ...
    def enable_sun_light(self, arg0: bool) -> None: ...
    def has_geometry(self, arg0: str) -> bool: ...
    def remove_camera(self, arg0: str) -> None: ...
    @overload
    def remove_light(self, arg0: str) -> None: ...
    @overload
    def remove_light(name) -> Any: ...
    def render_to_depth_image(
        self, arg0: Callable[[open3d.geometry.Image], None]
    ) -> None: ...
    def render_to_image(
        self, arg0: Callable[[open3d.geometry.Image], None]
    ) -> None: ...
    def set_active_camera(self, arg0: str) -> None: ...
    def set_indirect_light(self, arg0: str) -> bool: ...
    def set_indirect_light_intensity(self, arg0: float) -> None: ...
    def set_sun_light(
        self,
        arg0: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg1: npt.NDArray[Annotated[np.int32, "3,1"]],
        arg2: float,
    ) -> None: ...
    def update_geometry(
        self, arg0: str, arg1: open3d.t.geometry.PointCloud, arg2: int
    ) -> None: ...
    def update_light_color(
        self, arg0: str, arg1: npt.NDArray[Annotated[np.int32, "3,1"]]
    ) -> None: ...
    def update_light_cone_angles(self, arg0: str, arg1: float, arg2: float) -> None: ...
    def update_light_direction(
        self, arg0: str, arg1: npt.NDArray[Annotated[np.int32, "3,1"]]
    ) -> None: ...
    def update_light_falloff(self, arg0: str, arg1: float) -> None: ...
    def update_light_intensity(self, arg0: str, arg1: float) -> None: ...
    def update_light_position(
        self, arg0: str, arg1: npt.NDArray[Annotated[np.int32, "3,1"]]
    ) -> None: ...

class TriangleMeshModel:
    class MeshInfo:
        material_idx: int
        mesh: open3d.geometry.TriangleMesh
        mesh_name: str
        def __init__(
            self, arg0: open3d.geometry.TriangleMesh, arg1: str, arg2: int
        ) -> None: ...
    materials: List[MaterialRecord]
    meshes: List[TriangleMeshModel.MeshInfo]
    def __init__(self) -> None: ...

class View:
    class ShadowType:
        __members__: ClassVar[dict] = ...  # read-only
        PCF: ClassVar[View.ShadowType] = ...
        VSM: ClassVar[View.ShadowType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def __init__(self, *args, **kwargs) -> None: ...
    def get_camera(self) -> Camera: ...
    def set_ambient_occlusion(
        self, enabled: bool, ssct_enabled: bool = ...
    ) -> None: ...
    def set_antialiasing(self, enabled: bool, temporal: bool = ...) -> None: ...
    def set_color_grading(self, arg0: ColorGrading) -> None: ...
    def set_post_processing(self, arg0: bool) -> None: ...
    def set_sample_count(self, arg0: int) -> None: ...
    def set_shadowing(self, enabled: bool, type: View.ShadowType = ...) -> None: ...

__all__ = [
    "Camera",
    "ColorGrading",
    "Gradient",
    "MaterialRecord",
    "OffscreenRenderer",
    "Open3DScene",
    "Renderer",
    "Scene",
    "TriangleMeshModel",
    "View",
]
